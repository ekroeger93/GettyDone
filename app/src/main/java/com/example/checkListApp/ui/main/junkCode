package com.example.checkListApp.ui.main.EntryManagement;

import android.animation.Animator;
import android.animation.AnimatorListenerAdapter;
import android.animation.AnimatorSet;
import android.animation.ObjectAnimator;
import android.content.Context;
import android.graphics.Color;
import android.util.Log;
import android.view.View;
import android.view.animation.AccelerateDecelerateInterpolator;
import android.view.animation.AnimationSet;
import android.view.animation.AnticipateOvershootInterpolator;
import android.view.animation.BounceInterpolator;
import android.view.animation.OvershootInterpolator;
import android.view.animation.TranslateAnimation;
import android.widget.TextView;

import androidx.recyclerview.selection.SelectionTracker;
import androidx.recyclerview.widget.RecyclerView;

import com.example.checkListApp.R;
import com.example.checkListApp.databinding.MainFragmentBinding;
import com.example.checkListApp.input.CustomEditText;
import com.example.checkListApp.input.DetectKeyboardBack;
import com.example.checkListApp.ui.main.Entry;
import com.example.checkListApp.ui.main.MainFragment;
import com.example.checkListApp.ui.main.MainViewModel;
import com.example.checkListApp.ui.main.RecyclerAdapter;
import com.example.checkListApp.ui.main.Spacer;
import com.example.checkListApp.ui.main.ToggleSwitchOrdering;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.Objects;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.ReentrantLock;

public class EntryItemManager {


    private final Context context;
    private final MainViewModel mViewModel;
    private final Operator operator;

    ButtonPanelToggle buttonPanelToggle;


    public EntryItemManager(Context context, MainViewModel mainViewModel, Operator operator){

        this.context = context;
        this.mViewModel = mainViewModel;
        this.operator = operator;

    }

    public void setButtonPanelToggle(ButtonPanelToggle buttonPanelToggle) {
        this.buttonPanelToggle = buttonPanelToggle;
    }

    public void add(){

        Entry entry = new Entry();

        operator.adapter.notifyItemInserted(MainFragment.getCheckList().size() - 1);

        mViewModel.insertEntry(entry);

        operator.adapter.notifyItemChanged(MainFragment.getCheckList().size());

        operator.refreshSelection(false);

    }

    public void deleteSelected(SelectionTracker tracker){

        for(Entry entry : MainFragment.getCheckList()){

            try{


            if(tracker.isSelected(entry.getViewHolder().getKey()
            )){

                int position = entry.getViewHolder().getBindingAdapterPosition();

                mViewModel.deleteEntry(entry);
                operator.adapter.notifyItemRemoved(position);
                operator.adapter.notifyItemChanged(MainFragment.getCheckList().size());

            }
            }catch (NullPointerException e){
                e.printStackTrace();
            }


        }
        tracker.clearSelection();
    }


    /*
    lets attempt to do things in order of their swapIndex with Concurency

     try excluding the index of same toggle number

[1] eat some bacon  FIRST SWAP(1)
[2] go to work
[3] pick up laundry FIRST SWAP(2)<-- eat Some bacon

EXPECTED:
[1] go to work
[2] pick up laundry
[3] eat some bacon

     */

    static volatile String memoryEntry;
    static volatile String memoryEntrySwap;

    class TaskThread implements Runnable {

        Entry copyEntry;
        Entry copyEntrySwap;
//        Entry refEntry;
//        Entry refEntrySwap;
        int indexOf;
        int swapper;


        public TaskThread(Entry copyEntry, Entry copyEntrySwap, Entry refEntry, Entry refEntrySwap, int indexOf, int swapper) {
            this.copyEntry = copyEntry;
            this.copyEntrySwap = copyEntrySwap;
//            this.refEntry = refEntry;
//            this.refEntrySwap = refEntrySwap;
            this.swapper = swapper;
            this.indexOf = indexOf;
        }

        public TaskThread(int indexOf, int swapper) {


            if(refEntry.getViewHolder().orderInt.getValue() == -1){
                int value = MainFragment.toggleSwitchOrdering.listToOrder.get(indexOf-1
                ).number;

                System.out.println("ERROR! "+value);

                copyEntrySwap = new Entry(MainFragment.getCheckList().get(value));
                refEntrySwap = MainFragment.getCheckList().get(value);

            }else {
                copyEntrySwap = new Entry(MainFragment.getCheckList().get(swapper));
                refEntrySwap = MainFragment.getCheckList().get(swapper);
            }


        }

        @Override
        public void run() {

            synchronized (lock){

                while(true){

                if (swapper != lock.doInOrder.get()) {
                    System.out.println("wait: "+Thread.currentThread());
                    try {
                       lock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                        break;
                    }

                } else {

                    final String textEntryOne = refEntry.textEntry.getValue();
                    final String textEntryTwo = refEntrySwap.textEntry.getValue();

                    final Boolean isCheckOne = copyEntry.checked.getValue();
                    final Boolean isCheckTwo = copyEntrySwap.checked.getValue();

                    if(memoryEntry == null)
                    memoryEntry = refEntry.textEntry.getValue();

                    if(memoryEntrySwap == null)
                    memoryEntrySwap = refEntrySwap.textEntry.getValue();

                    System.out.println("---------BEGIN--------");
                    System.out.println(Thread.currentThread());
                    System.out.println("index:  "+indexOf + "|| swapIndex: " +swapper + " order: "+lock.doInOrder.get());
                    System.out.println( "->  memEnt: "+ memoryEntry+" || memEntSwap: "+memoryEntrySwap);
                    System.out.println( "->  textEnt: "+ refEntry.textEntry.getValue()+" || textEntSwap: "+refEntrySwap.textEntry.getValue());


                        refEntry.textEntry.postValue(textEntryTwo);
                        refEntrySwap.textEntry.postValue(textEntryOne);


                    System.out.println( "->  textEntVal1: "+ refEntry.textEntry.getValue() +" || textEntVal2: "+refEntrySwap.textEntry.getValue());
                    System.out.println( "---------END---------");

                    refEntry.checked.postValue(isCheckTwo);
                    refEntrySwap.checked.postValue(isCheckOne);

                    lock.decrement();
                    lock.notify();

                    break;
                }
            }}

        }

    }




   private static class lockOrderObject{

        AtomicInteger doInOrder = new AtomicInteger(0);

        void setDoInOrder(int value){
            doInOrder.set(value);
        }

        void decrement(){
            doInOrder.getAndDecrement();
       }


    }

    static final lockOrderObject lock = new lockOrderObject();


    int getHighestSwapActivated(){

        int highest = 0;

        for(Entry entry : MainFragment.getCheckList()){
            RecyclerAdapter.ViewHolder viewHolder = entry.getViewHolder();

        if(entry instanceof Spacer){}else {

            try{
            if (highest < viewHolder.orderInt.getValue() && viewHolder.isSelected.getValue())
                highest = viewHolder.orderInt.getValue();}
            catch (NullPointerException e){
            continue;
            }

        }

        }
        return highest;
    }

    volatile  Entry refEntry;
    volatile  Entry refEntrySwap;

    public void sortSelected(SelectionTracker<Long> tracker){

        MainFragment.updateAllSelection();

       // doInOrder = getHighestSwapActivated();


        lock.setDoInOrder(getHighestSwapActivated());


        for(ToggleSwitchOrdering.tNumber tNumber : MainFragment.toggleSwitchOrdering.listToOrder){

                 if(tNumber.toggle)
                {


//                    refEntry = MainFragment.getCheckList().get(selectIndex);
//              //  Entry copyEntry = new Entry(refEntry);
//
//                int swapper = refEntry.getViewHolder().orderInt.getValue();
//
//                int indexOf = MainFragment.getCheckList().indexOf(refEntry);

              //  Entry refEntrySwap ; //= MainFragment.getCheckList().get(swapper);
            //    Entry copyEntrySwap ; //= new Entry(refEntrySwap);


            //    System.out.println("...sorting");


//                if(refEntry.getViewHolder().orderInt.getValue() == -1){
//
//                            int value = MainFragment.toggleSwitchOrdering.listToOrder.get(indexOf-1
//                            ).number;
//
//                            System.out.println("ERROR! "+value);
//
//                             copyEntrySwap = new Entry(MainFragment.getCheckList().get(value));
//                             refEntrySwap = MainFragment.getCheckList().get(value);
//
//                        }else {
//
//                            // swapTemp = MainFragment.getCheckList().get(indexSwap);
//                            copyEntrySwap = new Entry(MainFragment.getCheckList().get(swapper));
//                            refEntrySwap = MainFragment.getCheckList().get(swapper);
//                        }





                    //    new Operator.TaskSortItem2(operator.adapter, copyEntry,copyEntrySwap,refEntry,refEntrySwap).run();

                      new Thread (new TaskThread(indexOf, swapper)).start();



        }
        }



    }





        if (!isMovingItem) {
            operator.movingItem = MainFragment.getCheckList().get(selection - 1);
            operator.oldMovePosition = selection - 1;
            operator.movingItem.setViewHolder(MainFragment.getCheckList().get(selection - 1).getViewHolder());
            operator.movingItem.getViewHolder().itemView.setBackgroundColor(Color.BLUE);
            operator.moveItem(operator.movingItem);
            buttonPanelToggle.toggleDisableToButton();
            ;

        }else{
            operator.adapter.notifyItemChanged(selection-1);
            operator.movingItem = null;
            buttonPanelToggle.toggleDisableToButton();
        }

        operator.isMovingItem = !isMovingItem;

    }

    public void edit(){



      //  if (operator.currentViewHolder.getAdapterPosition() == -1) {
            operator.currentViewHolder = operator.recyclerView.findViewHolderForAdapterPosition(operator.selection - 1);
     //   }

        TextView textHolderText = operator.currentViewHolder.itemView.findViewById(R.id.entryText);
        CustomEditText editHolderText = operator.currentViewHolder.itemView.findViewById(R.id.entryEditTxt);

        new DetectKeyboardBack(
                context,
                editHolderText,
                textHolderText, MainFragment.getCheckList().get(operator.selection - 1));

        operator.recyclerView.smoothScrollToPosition(operator.selection - 1);

      //  operator.recyclerView.scrollToPosition(operator.selection - 1 );

    }






}
